{
  "name": "presence",
  "type": "registry:component",
  "files": [
    {
      "path": "components/presence.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ninterface StateMachineConfig<TState extends string, TEvent extends string> {\n  initial: TState;\n  states: Record<TState, Partial<Record<TEvent, TState>>>;\n}\n\nfunction useStateMachine<TState extends string, TEvent extends string>(\n  config: StateMachineConfig<TState, TEvent>,\n) {\n  const [state, setState] = React.useState<TState>(config.initial);\n\n  const send = React.useCallback(\n    (event: TEvent) => {\n      setState((currentState) => {\n        const transition = config.states[currentState]?.[event];\n        return transition ?? currentState;\n      });\n    },\n    [config.states],\n  );\n\n  return [state, send] as const;\n}\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName ?? \"none\";\n}\n\ninterface PresenceProps {\n  present: boolean;\n  children?:\n    | React.ReactElement<{ ref?: React.Ref<HTMLElement> }>\n    | ((props: { present: boolean }) => React.ReactElement<{\n        ref?: React.Ref<HTMLElement>;\n      }>);\n  forceMount?: boolean;\n  onExitComplete?: () => void;\n}\n\nfunction Presence({\n  present,\n  children,\n  forceMount = false,\n  onExitComplete,\n}: PresenceProps) {\n  const [node, setNode] = React.useState<HTMLElement | null>(null);\n  const stylesRef = React.useRef<CSSStyleDeclaration>(\n    {} as CSSStyleDeclaration,\n  );\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>(\"none\");\n  const initialState = present ? \"mounted\" : \"unmounted\";\n\n  const [state, send] = useStateMachine({\n    initial: initialState,\n    states: {\n      mounted: {\n        UNMOUNT: \"unmounted\",\n        ANIMATION_OUT: \"unmountSuspended\",\n      },\n      unmountSuspended: {\n        MOUNT: \"mounted\",\n        ANIMATION_END: \"unmounted\",\n      },\n      unmounted: {\n        MOUNT: \"mounted\",\n      },\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current =\n      state === \"mounted\" ? currentAnimationName : \"none\";\n  }, [state]);\n\n  React.useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send(\"MOUNT\");\n      } else if (node) {\n        const hasAnimation =\n          (currentAnimationName !== \"none\" && styles?.display !== \"none\") ||\n          (styles.transitionProperty !== \"none\" &&\n            Number.parseFloat(styles.transitionDuration) > 0);\n\n        if (!hasAnimation) {\n          send(\"UNMOUNT\");\n        } else {\n          const isAnimating = prevAnimationName !== currentAnimationName;\n          if (wasPresent && isAnimating) {\n            send(\"ANIMATION_OUT\");\n          } else {\n            send(\"UNMOUNT\");\n          }\n        }\n      } else {\n        send(\"UNMOUNT\");\n      }\n      prevPresentRef.current = present;\n    }\n  }, [present, node, send]);\n\n  React.useLayoutEffect(() => {\n    if (!node) return;\n\n    let timeoutId: number;\n    const ownerWindow = node.ownerDocument.defaultView ?? window;\n\n    function onAnimationEnd(event: AnimationEvent) {\n      if (!node) return;\n      const currentAnimationName = getAnimationName(stylesRef.current);\n      const isCurrentAnimation = currentAnimationName.includes(\n        event.animationName,\n      );\n\n      if (event.target === node && isCurrentAnimation) {\n        send(\"ANIMATION_END\");\n        if (!prevPresentRef.current) {\n          const currentFillMode = node.style.animationFillMode;\n          node.style.animationFillMode = \"forwards\";\n          timeoutId = ownerWindow.setTimeout(() => {\n            if (node && node.style.animationFillMode === \"forwards\") {\n              node.style.animationFillMode = currentFillMode;\n            }\n          });\n        }\n      }\n    }\n\n    function onTransitionEnd(event: TransitionEvent) {\n      if (!node) return;\n      if (event.target === node && !prevPresentRef.current) {\n        send(\"ANIMATION_END\");\n      }\n    }\n\n    function onAnimationStart(event: AnimationEvent) {\n      if (!node) return;\n      if (event.target === node) {\n        prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n      }\n    }\n\n    node.addEventListener(\"animationstart\", onAnimationStart);\n    node.addEventListener(\"animationend\", onAnimationEnd);\n    node.addEventListener(\"animationcancel\", onAnimationEnd);\n    node.addEventListener(\"transitionend\", onTransitionEnd);\n    node.addEventListener(\"transitioncancel\", onTransitionEnd);\n\n    return () => {\n      ownerWindow.clearTimeout(timeoutId);\n      if (!node) return;\n      node.removeEventListener(\"animationstart\", onAnimationStart);\n      node.removeEventListener(\"animationend\", onAnimationEnd);\n      node.removeEventListener(\"animationcancel\", onAnimationEnd);\n      node.removeEventListener(\"transitionend\", onTransitionEnd);\n      node.removeEventListener(\"transitioncancel\", onTransitionEnd);\n    };\n  }, [node, send]);\n\n  React.useEffect(() => {\n    if (state === \"unmounted\" && !present && onExitComplete) {\n      onExitComplete();\n    }\n  }, [state, present, onExitComplete]);\n\n  const isPresent = [\"mounted\", \"unmountSuspended\"].includes(state);\n\n  if (!isPresent && !forceMount) return null;\n\n  const child =\n    typeof children === \"function\"\n      ? children({ present: isPresent })\n      : React.Children.only(children);\n\n  if (!child) return null;\n\n  return React.cloneElement(child, {\n    ref: (node: HTMLElement | null) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    },\n  });\n}\n\nexport { Presence };\n",
      "type": "registry:component",
      "target": ""
    }
  ]
}